import{_ as a,o as l,c as o,k as t,t as p,Q as s}from"./chunks/framework.419948d5.js";const _=JSON.parse('{"title":"了解前端安全","description":"远美网是一个vite与vitepress搭建的静态站点，记录着工作中有意义的事情，提供技术支持。","frontmatter":{"title":"了解前端安全","editLink":true,"head":[["meta",{"name":"description","content":"远美网是一个vite与vitepress搭建的静态站点，记录着工作中有意义的事情，提供技术支持。"}],["meta",{"name":"keywords","content":"JavaScript,safe,安全,前端安全,SCRF,XSS,攻击"}]]},"headers":[],"relativePath":"note/web-safe.md","filePath":"note/web-safe.md"}'),n={name:"note/web-safe.md"},c=s(`<h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>最近线上项目被他人攻击，对网站危害极大。之前对前端安全知识只是大致了解，简单应用。为了更详细的了解与应用前端安全知识，因此查找与前端安全相关材料抱着求学的心态系统地学习前端安全知识，在这里做个简单的总结，希望在日常开发中不断预防和修复漏洞。</p><p>典型的前端安全有XSS攻击和CSRF攻击，本篇主要从这两方面阐述。</p><p><strong>XSS的介绍</strong></p><p>XSS全称Cross-Site Scripting(跨站脚本攻击)，是一种代码注入攻击。攻击者在目标网站上注入恶意脚本，能在用户的浏览器上运行。利用恶意脚本，攻击者可以获取用户敏感信息，如：Cookie等，进行攻击危害数据。</p><h3 id="xss存在的原因" tabindex="-1">XSS存在的原因 <a class="header-anchor" href="#xss存在的原因" aria-label="Permalink to &quot;XSS存在的原因&quot;">​</a></h3><p>在URL参数场景，用户输入提交给服务端的URL内容，没有进行充分的过滤。如果将所有不合法的参数和输入内容做充分的过滤，就不会导致在用户浏览器中执行攻击者的脚本。</p><p>只做URL参数过滤和用户提交内容过滤是不行的。因为攻击者可以使用各种方式绕过服务端的过滤，最典型的是对URL参数进行各种编码，比如: <code>escape/encodeURI/encodeURIComponent</code>/8进制/10进制/16进制绕过过滤。</p><p><strong>XSS攻击方式</strong></p><p>①、一个搜索页面，点击搜索页面url添加上了关键词，页面显示与关键词相关的内容。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;input type=&quot;text&quot; value=&quot;&lt;%= getParams(keyword)%&gt;&quot; /&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;button&gt;搜索&lt;/button&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;div&gt;显示搜索的内容：&lt;%= getParams(keyword)%&gt; &lt;/div&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;input type=&quot;text&quot; value=&quot;&lt;%= getParams(keyword)%&gt;&quot; /&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;button&gt;搜索&lt;/button&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;div&gt;显示搜索的内容：&lt;%= getParams(keyword)%&gt; &lt;/div&gt;</span></span></code></pre></div><ul><li>附：文中&lt;%= ... %&gt;语法参考EJS语法。</li></ul><p>文本框值没做任何处理，项目就上线了。某天收到一个神秘链接：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">http://www.xxx.com/search?keyword=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">http://www.xxx.com/search?keyword=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</span></span></code></pre></div><p>浏览器发送请求<code>http://www.xxx.com/search?keyword=&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>时，后端会解析URL中的请求参数keyword的值，得到<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，浏览器最终在页面搜索结果区域显示与关键词相关内容：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;div&gt;显示搜索的内容：&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; &lt;/div&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;div&gt;显示搜索的内容：&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; &lt;/div&gt;</span></span></code></pre></div><p>对于<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>浏览器无法分辨是否属于恶意代码，因此会执行脚本。</p><p>对于这种攻击方式，可以告诉浏览器这段内容是文本就可以了。可以选择进行转义字符：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;input type=&quot;text&quot; value=&quot;&lt;%= esHTML(getParams(keyword))%&gt;&quot; /&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;button&gt;搜索&lt;/button&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;div&gt;显示搜索的内容：&lt;%= esHTML(getParams(keyword))%&gt; &lt;/div&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;input type=&quot;text&quot; value=&quot;&lt;%= esHTML(getParams(keyword))%&gt;&quot; /&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;button&gt;搜索&lt;/button&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;div&gt;显示搜索的内容：&lt;%= esHTML(getParams(keyword))%&gt; &lt;/div&gt;</span></span></code></pre></div><p>转义规则：</p><table><thead><tr><th>字符</th><th>转义后的字符</th></tr></thead><tbody><tr><td>&#39;</td><td><code>&amp;#x27;</code></td></tr><tr><td>&amp;</td><td><code>&amp;amp;</code></td></tr><tr><td>&lt;</td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td><code>&amp;gt;</code></td></tr><tr><td>/</td><td><code>&amp;#x2F;</code></td></tr><tr><td>&quot;</td><td><code>&amp;quot;</code></td></tr></tbody></table><p>经过转义后：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;input type=&quot;text&quot; value=&quot;&amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;script&amp;gt;&quot; /&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;button&gt;搜索&lt;/button&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;div&gt;显示搜索的内容：</span></span>
<span class="line"><span style="color:#e1e4e8;">  &amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;script&amp;gt; </span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/div&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;input type=&quot;text&quot; value=&quot;&amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;script&amp;gt;&quot; /&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;button&gt;搜索&lt;/button&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;div&gt;显示搜索的内容：</span></span>
<span class="line"><span style="color:#24292e;">  &amp;lt;script&amp;gt;alert(&amp;#x27;xss&amp;#x27;)&amp;lt;script&amp;gt; </span></span>
<span class="line"><span style="color:#24292e;">&lt;/div&gt;</span></span></code></pre></div><p>通过<strong>转义字符恶意脚本</strong>被转义，浏览器<strong>不会执行</strong>恶意脚本，搜索到的与关键词相关内容也正常在页面中显示出来。有些情况只做HTML转义，并不是高枕无忧，比如下面场景。</p><p>②、超链接场景，页面正常显示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;a href=&quot;http://www.xxx.com/search?to=javascript:alert(&#39;xss&#39;);&quot;&gt;click&lt;/a&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;a href=&quot;http://www.xxx.com/search?to=javascript:alert(&#39;xss&#39;);&quot;&gt;click&lt;/a&gt;</span></span></code></pre></div><p>用户一旦进行点击，浏览器就会执行代码；这种场景如果使用上述转义字符规则：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;a href=&quot;http://www.xxx.com/search?to=javascript:alert(&amp;#x27;xss&amp;#x27;);&quot;&gt;click&lt;/a&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;a href=&quot;http://www.xxx.com/search?to=javascript:alert(&amp;#x27;xss&amp;#x27;);&quot;&gt;click&lt;/a&gt;</span></span></code></pre></div><p>显然是不可行的。因为href跟的是正确属性，浏览器无法分辨属性值是否属于恶意代码，用户点击恶意脚本会执行。</p><p>对于这种形式可以<strong>设置白名单</strong>预防攻击：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">var allowHTTP = [&#39;http&#39;, &#39;https&#39;];</span></span>
<span class="line"><span style="color:#e1e4e8;">var isAllow = isAllowFunc(allowHTTP, to);</span></span>
<span class="line"><span style="color:#e1e4e8;">if(!!isAllow) {</span></span>
<span class="line"><span style="color:#e1e4e8;">  &lt;a href=&quot;跳转到相应页面&quot;&gt;...&lt;/a&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">}else{</span></span>
<span class="line"><span style="color:#e1e4e8;">  &lt;a href=&quot;/404.html&quot;&gt;...&lt;/a&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">var allowHTTP = [&#39;http&#39;, &#39;https&#39;];</span></span>
<span class="line"><span style="color:#24292e;">var isAllow = isAllowFunc(allowHTTP, to);</span></span>
<span class="line"><span style="color:#24292e;">if(!!isAllow) {</span></span>
<span class="line"><span style="color:#24292e;">  &lt;a href=&quot;跳转到相应页面&quot;&gt;...&lt;/a&gt;</span></span>
<span class="line"><span style="color:#24292e;">}else{</span></span>
<span class="line"><span style="color:#24292e;">  &lt;a href=&quot;/404.html&quot;&gt;...&lt;/a&gt;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>通过该方式可知针对超链接跳转方式，如：<code>location.href=&quot;xxx&quot;或者&lt;a href=&quot;xxx&quot;&gt;&lt;/a&gt;；</code>甚至包括<code>&lt;script&gt;，&lt;style&gt;，&lt;img&gt;</code>等标签的src属性值，可以选择白名单校验禁止以<code>javascript: </code>开头的链接 (包括javascript大小写的拼写) 和其他非法的scheme。</p><p>③、有些情况把JSON数据直接写在HTML中：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;script&gt; var data = data.toJSON(); &lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;script&gt; var data = data.toJSON(); &lt;/script&gt;</span></span></code></pre></div><p>这种方式JSON也存在风险，并且插入的JSON不能进行转义。因为转义 &quot; 后JSON格式被破坏。</p><p>因此需要实现一个对JSON数据进行转义的方法。但是需要注意的是：</p><ul><li><p>当JSON中包含U+2028或U+2029这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。</p></li><li><p>当JSON中包含字符串<code>&lt;/script&gt;</code>时，当前的script标签将会被闭合，后面的字符串内容浏览器会按照HTML进行解析；通过增加下一个<code>&lt;script&gt;</code>标签等方法就可以完成注入。</p></li></ul><p>转义规则：</p><table><thead><tr><th>字符</th><th>转义后的字符</th></tr></thead><tbody><tr><td>U+2028</td><td><code>\\u2028</code></td></tr><tr><td>U+2029</td><td><code>\\u2029</code></td></tr><tr><td>&lt;</td><td><code>\\u003c</code></td></tr></tbody></table><p>修改后的代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;script&gt; var data = esJSON(data.toJSON()); &lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;script&gt; var data = esJSON(data.toJSON()); &lt;/script&gt;</span></span></code></pre></div><p>通过以上可知：</p><p>HTML<strong>转义</strong>是<strong>非常复杂</strong>的，在不同的场景要<strong>采用不同的转义规则</strong>。如果采用的方式不正确，很可能埋下XSS隐患。因此尽量避免自己写转义库，<strong>应采用成熟，通用的转义库</strong>。</p><h3 id="归纳注入方式" tabindex="-1">归纳注入方式 <a class="header-anchor" href="#归纳注入方式" aria-label="Permalink to &quot;归纳注入方式&quot;">​</a></h3><ul><li>在HTML中内嵌恶意内容以script标签形式注入。</li><li>在HTML中拼接的JavaScript数据突破了原本的限制(字符串，变量等)。</li><li>在标签属性中，恶意内容包含引号，突破属性值的限制，注入其他属性或标签。</li><li>在标签style，href，src等属性中，包含JavaScript等可执行代码。</li><li>在onload，onclick等事件中注入不受控制的代码。</li><li>在style属性和标签中，包含background: url(&#39;JavaScript...&#39;)类似代码。</li><li>在style属性和标签中，包含expression(...)类似CSS表达式代码。</li></ul><h3 id="xss攻击分类" tabindex="-1">XSS攻击分类 <a class="header-anchor" href="#xss攻击分类" aria-label="Permalink to &quot;XSS攻击分类&quot;">​</a></h3><p>根据攻击的来源，可以将XSS攻击分以下类型：</p><ul><li>存储型攻击</li></ul><p>该攻击常见于论坛博主发贴，网站用户评论，网站用户留言等场景，攻击者将<strong>恶意脚本存储到目标网站</strong>上。</p><p>实现方式： 1、攻击者将恶意脚本提交到目标网站数据库中。 2、用户打开该网站浏览时，浏览器发送请求恶意脚本从数据库中读取，拼接在页面HTML中。 3、浏览器接收到响应后解析执行。 4、混在其中的恶意脚本也被执行，恶意脚本窃取用户数据，如：Cookie，发送到攻击者网站。</p><ul><li>反射型攻击</li></ul><p>该攻击常见于网站搜索，跳转等场景，通过URL传递参数，需要用户主动打开恶意的URL才会生效。攻击者将<strong>恶意脚本存储到URL</strong>里。</p><p>实现方式： 1、攻击者构造出特殊的URL并添加恶意脚本。 2、用户打开带有恶意脚本的URL，服务端将恶意脚本从URL中取出，拼接在HTML中返回给浏览器。 3、浏览器接收到响应后解析执行。 4、混在其中的恶意脚本也被执行，恶意脚本窃取用户数据，如：Cookie，发送到攻击者网站。</p><ul><li>DOM型攻击</li></ul><p>该攻击常发生于用户的输入来动态的构造一个DOM节点场景，如果没有对用户的输入进行过滤，很有可能造成XSS攻击。<strong>基于DOM的XSS</strong>取出恶意脚本和执行恶意脚本<strong>由浏览器端完成</strong>，服务端不参与。</p><p>实现方式： 1、攻击者构造出特殊的URL并添加恶意脚本。 2、用户打开带有恶意脚本的URL。 3、浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意脚本并执行。 4、恶意脚本窃取用户数据，如：Cookie，发送到攻击者网站。</p><h3 id="xss防御策略" tabindex="-1">XSS防御策略 <a class="header-anchor" href="#xss防御策略" aria-label="Permalink to &quot;XSS防御策略&quot;">​</a></h3>`,57),i=t("li",null,"客户端对用户有明确的输入类型，例如：数字，URL，手机号，邮箱等内容进行安全符转义，服务端对提交的内容进行安全转义。",-1),r=t("li",null,"对输入和URL参数进行过滤，对输出进行编码；和白名单结合。",-1),d=t("li",null,"避免拼接HTML。如果框架允许，使用createElement，setAttribute等之类的方法实现，或者采用比较成熟的框架，如：Vue/React。",-1),g=t("li",null,"要警惕插入位置为DOM属性，链接等位置。",-1),u=t("li",null,"服务端渲染开启模版引擎自带的HTML转义功能。",-1),h=t("li",null,"增加验证码功能，防止脚本冒充用户提交危险操作。",-1),m=t("li",null,"限制用户输入长度，增加攻击的难度。",-1),v=t("li",null,"设置Http-Only Cookie 禁止JavaScript读取敏感Cookie，攻击者完成XSS注入也无法窃取Cookie。",-1),y=t("li",null,"避免第三方跨域提交内容到服务端。",-1),k=s(`<h3 id="csrf的介绍" tabindex="-1">CSRF的介绍 <a class="header-anchor" href="#csrf的介绍" aria-label="Permalink to &quot;CSRF的介绍&quot;">​</a></h3><p>CSRF全称Cross-Site Request Forgery(跨站请求伪造)，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h3 id="csrf的特点" tabindex="-1">CSRF的特点 <a class="header-anchor" href="#csrf的特点" aria-label="Permalink to &quot;CSRF的特点&quot;">​</a></h3><ul><li>攻击一般在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是冒用。</li><li>跨站请求可以用各种方式，如：图片URL，超链接，Form等。部分请求方式可以直接嵌入在第三方论坛中，难以追踪。</li></ul><p><strong>CSRF通常是跨域的</strong>，因为<strong>外域</strong>通常更容易被攻击者<strong>掌握</strong>。反之，在本域下进行，如：可以发链接的评论，攻击反而更加危险。</p><h3 id="csrf攻击分类" tabindex="-1">CSRF攻击分类 <a class="header-anchor" href="#csrf攻击分类" aria-label="Permalink to &quot;CSRF攻击分类&quot;">​</a></h3><ul><li>GET类型的CSRF</li></ul><p>该攻击方式只需要一个HTTP请求，一般是这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;img src=&quot;http://www.xxx.com?time=100&amp;keyword=get&quot; alt=&quot;&quot; /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;img src=&quot;http://www.xxx.com?time=100&amp;keyword=get&quot; alt=&quot;&quot; /&gt;</span></span></code></pre></div><p>受害者在访问这个图片页面后，浏览器自动向：<code>http://www.xxx.com?account=danger&amp;time=100&amp;keyword=get</code>发送一次HTTP请求。<code>www.xxx.com</code>会包含受害者登录信息的一次跨域请求。</p><ul><li>POST类型的CSRF。</li></ul><p>该攻击方式通常使用的是一个自动提交的表单：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;form action=&quot;http://www.xxx.com&quot; method=&quot;POST&quot;&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">  &lt;input type=&quot;hidden&quot; name=&quot;time&quot; value=&quot;100&quot; /&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/form&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;form action=&quot;http://www.xxx.com&quot; method=&quot;POST&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">  &lt;input type=&quot;hidden&quot; name=&quot;time&quot; value=&quot;100&quot; /&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/form&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span></span></code></pre></div><p>用户访问该页面，表单会自动提交，完成了模拟POST操作。一般在网站上传功能上很有可能是发起攻击的来源。</p><ul><li>链接类型的CSRF。</li></ul><p>该攻击方式通常发生在论坛发布图片嵌入恶意链接，或者以广告的形式诱导用户点击，如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;a href=&quot;http://www.xxx.com/csrf&quot;&gt;充1元送1000&lt;/a&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;a href=&quot;http://www.xxx.com/csrf&quot;&gt;充1元送1000&lt;/a&gt;</span></span></code></pre></div><p>这种方式是用户之前登录了信任网站A，并且保存了登录状态。只要用户主动访问这个页面，攻击者就能攻击成功。</p><h3 id="csrf防御策略" tabindex="-1">CSRF防御策略 <a class="header-anchor" href="#csrf防御策略" aria-label="Permalink to &quot;CSRF防御策略&quot;">​</a></h3><ul><li>添加token验证</li></ul><p>本站点的接口请求前在头部添加token用于鉴别身份，第三方站点不能获取头部token。</p><p>该方式弊端：token鉴权对服务器压力较大；页面form提交，超链接不能形成统一的token增加入口，造成部分疏漏。</p><ul><li>服务端通过Referer Header和Origin Header进行同源验证。</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;a href=&quot;http://www.xxx.com/csrf&quot; referrerpolicy=&quot;no-referrer&quot;&gt;...&lt;/a&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;a href=&quot;http://www.xxx.com/csrf&quot; referrerpolicy=&quot;no-referrer&quot;&gt;...&lt;/a&gt;</span></span></code></pre></div><p>该方式弊端： 1、可以部分修改或隐藏Referer。 2、在低版本浏览器下对Referer和Origin不是很稳定。 3、在一些浏览器或操作会丢失Origin头部，如：302重定向。 4、HTTPS跳转到HTTP，所有浏览器Referer都会丢失。</p><ul><li>禁止第三方网站获取Cookie。</li></ul><p>可以设置Chrome的SameSite属性，而SameSite兼容性不好。</p><ul><li>利用双重Cookie认证。</li></ul><p>每个请求的参数都添加scrfCookie=&#39;随机数&#39; 防御参数，并在Cookie中混入该防御参数值，服务端请求头部的Cookie中的Cookie参数和请求参数所带的该参数进行对比。</p><p>该方式弊端： 如果前后端代码分离，前端和后端接口不同源，如：前端为<code>www.a.com</code>，后端为<code>api.a.com</code>，前端要拿到后端接口下的Cookie，必须将Cookie放在<code>a.com</code>下才能保证子域下都可以获取到，然而这样会增加XSS攻击风险。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本篇到这里算是结束了，从以上内容可以知晓：防范XSS是需要前端和后端共同参与的，针对DOM型攻击需要前端完成，选择适合的转义库，在不同的上下文调用不同的转义规则；防范CSRF，自动防御策略需要使用同源检测(Referer和Origin验证)，主动防御策略增加Token验证或双重Cookie验证，以及配合Samesite Cookie。为了更好的防御，最佳实践应结合防御措施优缺点和Web应用程序自身情况选择适合方案。文章可能存在一些没有说清楚的地方或者有错的地方，欢迎指正~</p><p>参考资料：</p><ul><li>XSS防御方法总结</li><li><a href="https://www.cnblogs.com/meituantech/p/9718677.html" target="_blank" rel="noreferrer">前端安全系列（一）：如何防止XSS攻击？</a></li><li><a href="https://blog.csdn.net/MeituanTech/article/details/83023558" target="_blank" rel="noreferrer">前端安全系列之二：如何防止CSRF攻击？</a></li></ul>`,34);function x(e,b,q,S,w,f){return l(),o("div",null,[c,t("ul",null,[i,r,d,g,t("li",null,`尽量不要使用onClick="fn('`+p(e.data)+`')"等形式内联事件的写法。可以通过addEventListener事件绑定更安全。`,1),u,h,m,v,y]),k])}const T=a(n,[["render",x]]);export{_ as __pageData,T as default};
